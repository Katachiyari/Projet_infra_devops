## Étape 1 — Stabiliser la “base CI” GitLab (SSOT + Runner + Registry)

Objectif : garantir qu’un pipeline peut **tourner** et **pousser une image** quelque part.

1. **GitLab accessible en SSOT** (`https://git-lab.lab.local`)
2. **Runner opérationnel** (enregistré, executor Docker OK)
3. **Registry cible** : on choisit clairement **Harbor** comme registry CI/CD (puisque c’est ton choix)

   * On valide : login, push/pull depuis un job CI
   * On évite de partir sur le registry GitLab en parallèle (sinon dette/ambiguïté)

Livrable minimal : un pipeline “smoke” qui fait `docker build` + `docker push` vers Harbor.

---

## Étape 2 — Poser l’ossature du pipeline (stages + quality gates)

Objectif : pipeline cohérent, reproductible, et qui bloque correctement.

* `validate` : Ruff
* `test` : pytest (même 1–2 tests simples)
* `security` : Bandit + Gitleaks + pip-audit
* `build` : tag + push Harbor
* (Option) `security-image` : Trivy sur l’image buildée

Livrable : `.gitlab-ci.yml` stable, avec règles (rules), cache pip, artefacts utiles, et tags d’image propres.

---

## Étape 3 — Observabilité CI/CD (Prometheus + Grafana + Alertmanager)

Objectif : voir et alerter sur l’état de la plateforme (et du reverse-proxy).

1. **Exporter / métriques Nginx reverse-proxy** (si pas déjà)
2. **Prometheus scrappe** (targets up)
3. **Grafana dashboards** (au moins : Nginx, Docker/Node, GitLab si possible)
4. **Alertmanager** : route simple + 1 règle d’alerte (ex : instance down)

Livrable : “preuve” monitoring (dashboard + alerte test).

---

## Étape 4 — Intégrations applicatives (Taiga)

Objectif : démontrer valeur métier / collaboration.

* SSO/ OAuth éventuellement plus tard (trop long)
* Minimum viable : liens GitLab ↔ Taiga (webhooks, références issues, etc.) selon ce que Taiga permet dans ta version

---

# Pourquoi cet ordre est le meilleur

* Sans **Runner + Registry**, tu ne peux pas valider la CI/CD (donc tout le reste est du “théorique”).
* Sans un **pipeline minimal stable**, tu ne sais pas ce que tu dois monitorer (volumes, erreurs, latences, échecs).
* L’observabilité devient ensuite un **accélérateur** (tu diagnostiqueras plus vite Harbor/GitLab/Runner).

---

## Étape 1 (démarrage concret) — Le tout premier test à faire

* Valider que le runner peut exécuter un job Docker
* Valider que le job peut `docker login` Harbor et `docker push`

Dès que tu dis **“suivant”**, je te donne **uniquement l’étape 1** sous forme de checklist + commandes minimales (éco prompts), avec points de contrôle et symptômes/causes fréquentes.
